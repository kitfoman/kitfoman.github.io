<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Procedural Cube – WebGL Demo</title>
    <style>
      /* --- layout --- */
      html, body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #000;
        font-family: system-ui, sans-serif;
      }
      header {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        padding: 0.5rem 1rem;
        backdrop-filter: blur(4px);
        background: rgba(0, 0, 0, 0.3);
        color: #fff;
        font-size: 0.9rem;
        z-index: 10;
      }
      header a {
        color: #8ad;
        text-decoration: none;
        margin-right: 1rem;
      }
      #gl {
        width: 100vw;
        height: 100vh;
        display: block;
      }
    </style>
  </head>
  <body>
    <header>
      <a href="/">Home</a>
      <a href="https://shadertoy.com" target="_blank" rel="noopener">ShaderToy ↗</a>
      <a href="https://github.com/YOUR-USER" target="_blank" rel="noopener">GitHub ↗</a>
    </header>
    <canvas id="gl"></canvas>

    <!-- Three.js (latest)  -->
    <script src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>

    <script>
      // --- Shaders --------------------------------------------------------
      // Pass‑through vertex shader
      const vert = /* glsl */ `
        attribute vec3 position;
        void main() {
          gl_Position = vec4(position, 1.0);
        }
      `;

      // Fragment shader – ray‑marched rotating cube.  Replace the block
      // inside main() with any ShaderToy fragment (remember to declare
      // iResolution / iTime as uniforms).
      const frag = /* glsl */ `
        precision highp float;
        uniform vec2  iResolution;
        uniform float iTime;

        // Signed‑distance function for a box of half‑sizes b
        float sdBox( in vec3 p, in vec3 b ) {
          vec3 d = abs(p) - b;
          return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
        }

        void main() {
          // Normalised pixel coords (‑1..1)
          vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;

          // Camera ray origin & direction
          vec3 ro = vec3(0.0, 0.0, 3.0);
          vec3 rd = normalize(vec3(uv, -1.5));

          // Spin the scene around Y over time
          float a = iTime * 0.8;
          mat3 ry = mat3( cos(a), 0.0, sin(a),
                          0.0,    1.0, 0.0,
                         -sin(a), 0.0, cos(a));
          rd = ry * rd;

          float t = 0.0;     // current march distance
          float hit = -1.0;  // will stay <0.0 if we miss
          for (int i = 0; i < 80; i++) {
            vec3 pos = ro + t * rd;
            float d = sdBox(pos, vec3(0.75));
            if (d < 0.002) { hit = t; break; }
            t += d;
            if (t > 20.0) break;
          }

          vec3 col = vec3(0.0);
          if (hit > 0.0) {
            col = mix(vec3(0.2, 0.6, 1.0), vec3(0.9, 0.4, 0.1), hit / 3.0);
          }

          // Gamma‑correct output
          gl_FragColor = vec4(pow(col, vec3(1.0/2.2)), 1.0);
        }
      `;

      // --- Three.js bootstrap ---------------------------------------------
      const canvas = document.getElementById('gl');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);

      const scene = new THREE.Scene();
      const camera = new THREE.Camera(); // NDC camera for full‑screen quad

      const uniforms = {
        iTime: { value: 0 },
        iResolution: { value: new THREE.Vector2() }
      };

      const material = new THREE.RawShaderMaterial({
        vertexShader: vert,
        fragmentShader: frag,
        uniforms,
        depthTest: false,
      });

      const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
      scene.add(quad);

      function resize() {
        const { innerWidth: w, innerHeight: h } = window;
        renderer.setSize(w, h, false);
        uniforms.iResolution.value.set(w, h);
      }
      window.addEventListener('resize', resize);
      resize();

      // main loop
      const clock = new THREE.Clock();
      function tick() {
        uniforms.iTime.value = clock.getElapsedTime();
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      }
      tick();
    </script>
  </body>
</html>

